# -*- coding: utf-8 -*-
"""Corona.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fi2Hn8Go5zeGg8JOzPKaNArlko_tkoVl

# Predicting Number of Corona Cases In the World

- Predicting the number of corona cases in the upcoming future.
- The dataset for this problem is taken from Kaggle.
(https://www.kaggle.com/imdevskp/corona-virus-report).
- The data of whole world is used to predicted the future cases of Corona.

## 1) Importing the libraries
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import torch
import torch.nn as nn

"""## 2) Importing the dataset"""

df = pd.read_csv('../corona-virus-report/covid_19_clean_complete.csv',parse_dates=['Date'])
df.head()

df.drop('Province/State',axis = 1,inplace=True)
df.head()

df.info() #Getting information about different columns datatype

df['Confirmed'].max(), df['Recovered'].max() , df['Deaths'].max()

"""## 3) Checking Plot for number of confirmed,recovered and deaths due to corona virus"""

plt.plot(df['Confirmed'])

plt.plot(df['Recovered'])

plt.plot(df['Deaths'])

"""## 4) Preprocessing the Data.

- We will be dealing with the number of confirmed cases of Corona
"""

df.groupby('Date').head()

X = df[['Date','Confirmed','Deaths','Recovered']]
X.head()

a = X.groupby(['Date']).sum()
print(a)

X = a['Confirmed']
X = X.to_frame()

X.columns

plt.figure(figsize=(12,4))
plt.title('Corona Count')
plt.ylabel('Increment everyday')
plt.grid(True)
plt.autoscale(axis='x',tight=True)
plt.plot(X['Confirmed'])
plt.show()

len(X)

"""## 5) Feature Scaling"""

window_size = 5
train_set = X[:-window_size].values
test_set = X[-window_size:].values

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(-1,1))
train_norm = scaler.fit_transform(train_set.reshape(-1,1))

"""## 6) Dividing the data into sequences for LSTM"""

window_size = 5
train_norm = torch.FloatTensor(train_norm).view(-1)
L = len(train_norm)
def input_data(seq,ws):
  out = []
  for i in range(L-ws):
    window = seq[i:i+ws]
    output = seq[i+ws:i+ws+1]
    out.append((window,output))

  return out  

training = input_data(train_norm,window_size)
len(training)

"""## 7) Building a RNN-LSTM model"""

class TableModel(nn.Module):
  def __init__(self,in_feature=1,hidden_size=40,out_feature=1,dropout=0.5):
    super().__init__()

    self.hidden_size = hidden_size

    self.lstm = nn.LSTM(in_feature,hidden_size)
    self.linear = nn.Linear(hidden_size,out_feature,dropout)
    self.hidden = (torch.zeros(1,1,self.hidden_size),torch.zeros(1,1,self.hidden_size))

  def forward(self,seq):
    lstm_out, self.hidden = self.lstm(seq.view(len(seq),1,-1), self.hidden)
    pred = self.linear(lstm_out.view(len(seq),-1))
    return pred[-1]  # we only want the last value

"""## 8) Initialising the model and declaring loss function and optimizer"""

model = TableModel()
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(),lr=0.0001)

model

"""## 9) Model training on train dataset"""

epochs = 1001

for i in range(epochs):
  for seq,y_train in training:    
    optimizer.zero_grad()
    model.hidden = (torch.zeros(1,1,model.hidden_size),
                    torch.zeros(1,1,model.hidden_size))
    
    y_pred = model(seq)
    
    loss = criterion(y_pred, y_train)
    loss.backward()
    optimizer.step()

  if i%100 == 0:
    print(f'Epoch : {i} and Loss : {loss.item()}')

"""## 10) Testing on the test dataset"""

future = 5

preds = train_norm[-window_size:].tolist()

model.eval()

for i in range(future):
  seq = torch.FloatTensor(preds[-window_size:])
  with torch.no_grad():

    model.hidden = (torch.zeros(1,1,model.hidden_size),torch.zeros(1,1,model.hidden_size))
    preds.append(model(seq).item())

preds[window_size:]

true_preds = scaler.inverse_transform(np.array(preds[window_size:]).reshape(-1,1))
true_preds

X.tail()

#x = pd.DataFrame(['2020-04-13','2020-04-14','2020-04-15','2020-04-16','2020-04-17'])

rng = pd.date_range('2020-04-13', periods=5)
df = pd.DataFrame({ 'Date': rng})
c = df['Date']

plt.figure(figsize=(12,4))
plt.title('Corona')
plt.ylabel('Count per Day')
plt.grid(True)
plt.autoscale(axis='x',tight=True)
plt.plot(X['Confirmed'])
plt.plot(c,true_preds)
plt.show()

"""## 11) Predicting the future value

### 11.1) Training on full dataset
"""

epochs = 1000

# set model to back to training mode
model.train()
y = X['Confirmed'].values
# feature scale the entire dataset
y_norm = scaler.fit_transform(y.reshape(-1, 1))
y_norm = torch.FloatTensor(y_norm).view(-1)
all_data = input_data(y_norm,window_size)

import time
start_time = time.time()

for epoch in range(epochs):
    
    # train on the full set of sequences
    for seq, y_train in all_data:  
        
        # reset the parameters and hidden states
        optimizer.zero_grad()
        model.hidden = (torch.zeros(1,1,model.hidden_size),
                        torch.zeros(1,1,model.hidden_size))
        
        y_pred = model(seq)
        
        loss = criterion(y_pred, y_train)
        loss.backward()
        optimizer.step()
        
    # print training result
    if epoch%100 == 0:
      print(f'Epoch: {epoch+1:2} Loss: {loss.item():10.8f}')
    
print(f'\nDuration: {time.time() - start_time:.0f} seconds')

"""### 11.2) Predicting Future Value for next 15 Days"""

window_size = 5
future = 15
L = len(y)

preds = y_norm[-window_size:].tolist()

model.eval()
for i in range(future):  
    seq = torch.FloatTensor(preds[-window_size:])
    with torch.no_grad():
        # Reset the hidden parameters here!
        model.hidden = (torch.zeros(1,1,model.hidden_size),
                        torch.zeros(1,1,model.hidden_size))  
        preds.append(model(seq).item())

# Inverse-normalize the prediction set
true_predictions = scaler.inverse_transform(np.array(preds).reshape(-1, 1))
true_predictions

"""## 12) Showing the future prediction in the form of graph and tabular form"""

rng = pd.date_range('2020-04-13', periods=20)
df = pd.DataFrame({ 'Date': rng})
c = df['Date']

import datetime
plt.figure(figsize=(16,4))
plt.title('Corona')
plt.ylabel('Count per Day')
plt.grid(True)
plt.autoscale(axis='x',tight=True)
plt.plot(X['Confirmed'])
plt.plot(c,true_predictions)
plt.xlim([datetime.date(2020, 1, 23), datetime.date(2020, 4, 28)])
plt.show()

true_pre = pd.DataFrame(true_predictions)
dates = pd.date_range('2020-04-13', periods=20)
x = dates.to_numpy()
print(x)
df = pd.DataFrame(x,columns=['Date'])
df['Prediction'] = true_pre
df

"""# Thank You!!!"""